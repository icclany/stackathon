<!DOCTYPE html>
<script src='vendor/require.js/require.js'></script>
<script src='vendor/three.js/build/three.min.js'></script>
<script src='../vendor/oimo.js'></script>
<script src='../threex.oimo.js'></script>
<script src='../ThreeCSG.js'></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'>
    <script>
    require(['../package.require.js', 'bower_components/threex.crates/package.require.js', 'bower_components/threex.grassground/package.require.js', 'bower_components/threex.daynight/package.require.js'], function() {
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor('lightgrey')
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var onRenderFcts = [];
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000)
        camera.position.z = 100
        camera.lookAt(scene.position)

        //////////////////////////////////////////////////////////////////////////////////
        //		oimo world							//
        //////////////////////////////////////////////////////////////////////////////////

        var world = new OIMO.World(1 / 120, 2, 8)
        setInterval(function() {
            world.step()
        }, 1000 / 60);

        //////////////////////////////////////////////////////////////////////////////////
        //		Ground								//
        //////////////////////////////////////////////////////////////////////////////////

        var geometry = new THREE.BoxGeometry(400, 20, 200);
        var material = new THREEx.GrassGround({
            repeatX: 5,
            repeatY: 5
        }).material;
        var mesh = new THREE.Mesh(geometry, material);
        mesh.receiveShadow = true;
        mesh.position.y = -geometry.parameters.height / 2
        scene.add(mesh)

        var ground = THREEx.Oimo.createBodyFromMesh(world, mesh, {
            move: false
        });

        //////////////////////////////////////////////////////////////////////////////////
        //		add an object and make it move					//
        //////////////////////////////////////////////////////////////////////////////////

        ;
        (function() {
            for (var i = 0; i < 100; i++) {
                (function() {
                    //////////////////////////////////////////////////////////////////////////////////
                    //		Sandbags
                    //////////////////////////////////////////////////////////////////////////////////
                    // if( Math.random() < 0.05 ){
                    var width = 5;
                    var height = 5;
                    var depth = 1.5;
                    var geometry = new THREE.BoxGeometry(width, height, depth)
                        // }else{
                        // 	var radius	= 3 + (Math.random()-0.5)*2
                        // 	var geometry	= new THREE.SphereGeometry( radius )
                        // }

                    var material = new THREE.MeshNormalMaterial()

                    var cloth = new THREE.MeshPhongMaterial({
                        map: THREE.ImageUtils.loadTexture('images/redfabric.jpg'),
                        normalScale: new THREE.Vector2(0.3, 0.3),
                    })

                    var mesh = new THREE.Mesh(geometry, cloth)
                    scene.add(mesh)

                    // Sandbag positioning: determined by accelerometer
                    mesh.position.x = (Math.random() - 0.5) * 40
                    mesh.position.y = 50 + (Math.random() - 0.5) * 40
                    mesh.position.z = (Math.random() - 0.5) * 40

                    //////////////////////////////////////////////////////////////////////////////////
                    //		create a body for this mesh
                    //////////////////////////////////////////////////////////////////////////////////

                    // create IOMO.Body from mesh
                    var body = THREEx.Oimo.createBodyFromMesh(world, mesh)

                    // add an updater for them
                    onRenderFcts.push(function(delta) {
                        THREEx.Oimo.updateObject3dWithBody(mesh, body)
                    })

                    //////////////////////////////////////////////////////////////////////////////////
                    //		if body is too low, reset it
                    //////////////////////////////////////////////////////////////////////////////////

                    // if the position.y < 20, reset the position
                    onRenderFcts.push(function(delta) {
                        if (mesh.position.y < -20) {
                            mesh.position.x = (Math.random() - 0.5) * 20
                            mesh.position.y = 100 + (Math.random() - 0.5) * 15
                            mesh.position.z = (Math.random() - 0.5) * 20
                            body.resetPosition(mesh.position.x, mesh.position.y, mesh.position.z);
                        }
                    })
                })()
            }

        })()

        //////////////////////////////////////////////////////////////////////////////////
        //		plank								//
        //////////////////////////////////////////////////////////////////////////////////
        ;
        (function() {
            var planks = [];
            for (var i = -20; i < 20; i++) {
                var plank = THREEx.Crates.createCrate2();
                if (Math.abs(i) < 6) {
                    plank.scale.y = 50;
                    plank.position.z = 14.2;
                    plank.position.y = 5.2;
                } else {
                    plank.scale.y = 80;
                    plank.position.y = 10;
                }
                plank.scale.z = 10;
                plank.rotation.x = 1.9;
                plank.position.x = i;
                planks.push(plank);
            }

            for (var j = -6; j < 6; j++) {
                var topPlank = THREEx.Crates.createCrate2();

                topPlank.scale.y = 18;
                topPlank.position.z = -29.5;
                topPlank.position.y = 20.05;

                topPlank.scale.z = 10;
                topPlank.rotation.x = 1.9;
                topPlank.position.x = j;
                planks.push(topPlank);
            }

            planks.forEach(plank => {
                scene.add(plank)
                THREEx.Oimo.createBodyFromMesh(world, plank, {
                    move: false
                })
            })
        })()

        //////////////////////////////////////////////////////////////////////////////////
        //		Camera Controls							//
        //////////////////////////////////////////////////////////////////////////////////
        var mouse = {
                x: 0,
                y: 0.95
            }
            document.addEventListener('mousemove', function(event){
            	mouse.x	= (event.clientX / window.innerWidth ) - 0.5
            	mouse.y	= (event.clientY / window.innerHeight) - 0.5
            	console.log(event.clientY);
            }, false)
        onRenderFcts.push(function(delta, now) {
            camera.position.x += (mouse.x * 500 - camera.position.x) * (delta * 3)
            camera.position.y += (mouse.y * 500 - (camera.position.y - 5)) * (delta * 3)
            camera.lookAt(scene.position)
        })

        //////////////////////////////////////////////////////////////////////////////////
        //		sunAngle								//
        //////////////////////////////////////////////////////////////////////////////////

        var sunAngle = -2 / 6 * Math.PI * 2;
        onRenderFcts.push(function(delta, now) {
            var dayDuration = 5 // nb seconds for a full day cycle
            if (sunAngle < 2) sunAngle += delta / dayDuration * Math.PI * 2
        })

        //////////////////////////////////////////////////////////////////////////////////
        //		directionalLight						//
        //////////////////////////////////////////////////////////////////////////////////


        var sunLight = new THREEx.DayNight.SunLight()
        scene.add(sunLight.object3d)
        onRenderFcts.push(function(delta, now) {
            sunLight.update(sunAngle)
        })

        //////////////////////////////////////////////////////////////////////////////////
        //		skydom								//
        //////////////////////////////////////////////////////////////////////////////////

        var skydom = new THREEx.DayNight.Skydom()
        scene.add(skydom.object3d)
        onRenderFcts.push(function(delta, now) {
            skydom.update(sunAngle)
        })


        //////////////////////////////////////////////////////////////////////////////////
        //		render the scene						//
        //////////////////////////////////////////////////////////////////////////////////
        onRenderFcts.push(function() {
            renderer.render(scene, camera);
        })

        //////////////////////////////////////////////////////////////////////////////////
        //		loop runner							//
        //////////////////////////////////////////////////////////////////////////////////
        var lastTimeMsec = null
        requestAnimationFrame(function animate(nowMsec) {
            // keep looping
            requestAnimationFrame(animate);
            // measure time
            lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
            var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
            lastTimeMsec = nowMsec
                // call each update function
            onRenderFcts.forEach(function(onRenderFct) {
                onRenderFct(deltaMsec / 1000, nowMsec / 1000)
            })
        })
    })
    </script>
</body>
